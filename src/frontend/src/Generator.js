// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Config from "./Config.js";
import * as $$Object from "./Object.js";
import * as Random from "rescript/lib/es6/random.js";
import * as Sprite from "./Sprite.js";

function memPos(objs, x, y) {
  return objs.some(function (param) {
              var px = param.px;
              var py = param.py;
              if (x === px) {
                return y === py;
              } else {
                return false;
              }
            });
}

function trimEdge(x, y, level) {
  var pixx = Config.blockw(level) * 16;
  var pixy = Config.blockh(level) * 16;
  return !(x < 128 || pixx - x < 528 || y === 0 || pixy - y < 48);
}

function convertCoinToObj(param, level) {
  var y = param[2];
  var x = param[1];
  var arg = Sprite.makeParams(/* Coin */1);
  return function (param) {
    return $$Object.make(false, undefined, undefined, param, level, {
                TAG: /* Item */3,
                _0: /* Coin */1
              }, arg, x, y);
  };
}

function addCoins(objects, x, y0, idCounter, level) {
  var y = y0 - 16;
  if (Random.bool(undefined) && trimEdge(x, y, level) && !memPos(objects, x, y)) {
    objects.push(convertCoinToObj([
                /* QBlockCoin */1,
                x,
                y
              ], level)(idCounter));
    return ;
  }
  
}

function convertEnemyToObj(param, idCounter, level) {
  var enemyTyp = param[0];
  var obj = $$Object.make(undefined, undefined, undefined, idCounter, level, {
        TAG: /* Enemy */2,
        _0: enemyTyp
      }, Sprite.enemyParams(enemyTyp, /* Left */0), param[1], param[2]);
  $$Object.setVelToSpeed(obj);
  return obj;
}

function randomEnemyTyp(param) {
  var match = Random.$$int(3);
  if (match !== 0) {
    if (match !== 1) {
      return /* Goomba */0;
    } else {
      return /* GKoopa */1;
    }
  } else {
    return /* RKoopa */2;
  }
}

function addEnemyOnBlock(objects, x, y, idCounter, level) {
  var placeEnemy = Random.$$int(Config.enemyDensity(level));
  if (placeEnemy === 0 && !memPos(objects, x, y - 16)) {
    objects.push(convertEnemyToObj([
              randomEnemyTyp(undefined),
              x,
              y - 16
            ], idCounter, level));
    return ;
  }
  
}

function addBlock(objects, blockTyp, xBlock, yBlock, idCounter, level) {
  var x = xBlock * 16;
  var y = yBlock * 16;
  if (!(!memPos(objects, x, y) && trimEdge(x, y, level))) {
    return ;
  }
  var obj = $$Object.make(undefined, undefined, undefined, idCounter, level, {
        TAG: /* Block */4,
        _0: blockTyp
      }, Sprite.blockParams(blockTyp), x, y);
  objects.push(obj);
  addCoins(objects, x, y, idCounter, level);
  return addEnemyOnBlock(objects, x, y, idCounter, level);
}

function generateGroundStairs(cbx, cby, typ, blocks, idCounter, level) {
  addBlock(blocks, typ, cbx, cby, idCounter, level);
  addBlock(blocks, typ, cbx + 1, cby, idCounter, level);
  addBlock(blocks, typ, cbx + 2, cby, idCounter, level);
  addBlock(blocks, typ, cbx + 3, cby, idCounter, level);
  addBlock(blocks, typ, cbx + 1, cby - 1, idCounter, level);
  addBlock(blocks, typ, cbx + 2, cby - 1, idCounter, level);
  addBlock(blocks, typ, cbx + 3, cby - 1, idCounter, level);
  addBlock(blocks, typ, cbx + 2, cby - 2, idCounter, level);
  addBlock(blocks, typ, cbx + 3, cby - 2, idCounter, level);
  return addBlock(blocks, typ, cbx + 3, cby - 3, idCounter, level);
}

function generateAirupStairs(cbx, cby, typ, blocks, idCounter, level) {
  addBlock(blocks, typ, cbx, cby, idCounter, level);
  addBlock(blocks, typ, cbx + 1, cby, idCounter, level);
  addBlock(blocks, typ, cbx + 3, cby - 1, idCounter, level);
  addBlock(blocks, typ, cbx + 4, cby - 1, idCounter, level);
  addBlock(blocks, typ, cbx + 4, cby - 2, idCounter, level);
  addBlock(blocks, typ, cbx + 5, cby - 2, idCounter, level);
  return addBlock(blocks, typ, cbx + 6, cby - 2, idCounter, level);
}

function generateAirdownStairs(cbx, cby, typ, blocks, idCounter, level) {
  addBlock(blocks, typ, cbx, cby, idCounter, level);
  addBlock(blocks, typ, cbx + 1, cby, idCounter, level);
  addBlock(blocks, typ, cbx + 2, cby, idCounter, level);
  addBlock(blocks, typ, cbx + 2, cby + 1, idCounter, level);
  addBlock(blocks, typ, cbx + 3, cby + 1, idCounter, level);
  addBlock(blocks, typ, cbx + 5, cby + 2, idCounter, level);
  return addBlock(blocks, typ, cbx + 6, cby + 2, idCounter, level);
}

function generateClouds(_cbx, cby, typ, _num, blocks, idCounter, level) {
  while(true) {
    var num = _num;
    var cbx = _cbx;
    if (num === 0) {
      return ;
    }
    addBlock(blocks, typ, cbx, cby, idCounter, level);
    _num = num - 1 | 0;
    _cbx = cbx + 1;
    continue ;
  };
}

function randomStairTyp(param) {
  if (Random.bool(undefined)) {
    return /* UnBBlock */4;
  } else {
    return /* Brick */3;
  }
}

function chooseBlockPattern(cbx, cby, objects, idCounter, level) {
  if (cbx > Config.blockw(level) || cby > Config.blockh(level)) {
    return ;
  }
  var stairTyp = randomStairTyp(undefined);
  var lifeBlock = Random.$$int(5) === 0;
  var middleBlock = lifeBlock ? /* QBlockMushroom */0 : stairTyp;
  var match = Random.$$int(5);
  switch (match) {
    case 0 :
        addBlock(objects, stairTyp, cbx, cby, idCounter, level);
        addBlock(objects, middleBlock, cbx + 1, cby, idCounter, level);
        return addBlock(objects, stairTyp, cbx + 2, cby, idCounter, level);
    case 1 :
        var numClouds = Random.$$int(5) + 5 | 0;
        if (cby < 5) {
          return generateClouds(cbx, cby, /* Cloud */5, numClouds, objects, idCounter, level);
        } else {
          return ;
        }
    case 2 :
        if (Config.blockh(level) - cby === 1) {
          return generateGroundStairs(cbx, cby, stairTyp, objects, idCounter, level);
        } else {
          return ;
        }
    case 3 :
        if (stairTyp === /* Brick */3 && Config.blockh(level) - cby > 3) {
          return generateAirdownStairs(cbx, cby, stairTyp, objects, idCounter, level);
        } else if (Config.blockh(level) - cby > 2) {
          return generateAirupStairs(cbx, cby, stairTyp, objects, idCounter, level);
        } else {
          return addBlock(objects, stairTyp, cbx, cby, idCounter, level);
        }
    default:
      if (cby + 3 - Config.blockh(level) === 2) {
        return addBlock(objects, stairTyp, cbx, cby, idCounter, level);
      } else if (cby + 3 - Config.blockh(level) === 1) {
        addBlock(objects, stairTyp, cbx, cby, idCounter, level);
        return addBlock(objects, stairTyp, cbx, cby + 1, idCounter, level);
      } else {
        addBlock(objects, stairTyp, cbx, cby, idCounter, level);
        addBlock(objects, stairTyp, cbx, cby + 1, idCounter, level);
        return addBlock(objects, stairTyp, cbx, cby + 2, idCounter, level);
      }
  }
}

function generateEnemiesOnGround(objects, _cbx, _cby, idCounter, level) {
  while(true) {
    var cby = _cby;
    var cbx = _cbx;
    if (cbx > Config.blockw(level) - 32) {
      return ;
    }
    if (cby > Config.blockh(level) - 1 || cbx < 15) {
      _cby = 0;
      _cbx = cbx + 1;
      continue ;
    }
    if (cby === 0 || Config.blockh(level) - 1 !== cby || Random.$$int(10) !== 0) {
      _cby = cby + 1;
      continue ;
    }
    objects.push(convertEnemyToObj([
              randomEnemyTyp(undefined),
              cbx * 16,
              cby * 16
            ], idCounter, level));
    _cby = cby + 1;
    continue ;
  };
}

function generateBlocks(objects, _cbx, _cby, idCounter, level) {
  while(true) {
    var cby = _cby;
    var cbx = _cbx;
    if (Config.blockw(level) - cbx < 33) {
      return ;
    }
    if (cby > Config.blockh(level) - 1) {
      _cby = 0;
      _cbx = cbx + 1;
      continue ;
    }
    if (memPos(objects, cbx, cby) || cby === 0) {
      _cby = cby + 1;
      continue ;
    }
    if (Random.$$int(20) === 0) {
      chooseBlockPattern(cbx, cby, objects, idCounter, level);
      _cby = cby + 1;
      continue ;
    }
    _cby = cby + 1;
    continue ;
  };
}

function generatePanel(idCounter, level) {
  return $$Object.make(undefined, undefined, undefined, idCounter, level, {
              TAG: /* Block */4,
              _0: /* Panel */6
            }, Sprite.blockParams(/* Panel */6), Config.blockw(level) * 16 - 256, Config.blockh(level) * 16 * 2 / 3);
}

function convertBlockToObj(param) {
  var y = param[2];
  var x = param[1];
  var blockTyp = param[0];
  var arg = {
    TAG: /* Block */4,
    _0: blockTyp
  };
  var arg$1 = Sprite.blockParams(blockTyp);
  return function (param) {
    var func = Curry._4($$Object.make, undefined, undefined, undefined, param);
    return function (param) {
      return Curry._5(func, param, arg, arg$1, x, y);
    };
  };
}

function generateGround(objects, _inc, idCounter, level) {
  while(true) {
    var inc = _inc;
    if (inc > Config.blockw(level)) {
      return ;
    }
    if (inc > 10) {
      var skip = Random.$$int(10);
      if (skip === 7 && Config.blockw(level) - inc > 32) {
        _inc = inc + 1;
        continue ;
      }
      objects.push(Curry._1(convertBlockToObj([
                      /* Ground */7,
                      inc * 16,
                      Config.blockh(level) * 16
                    ])(idCounter), level));
      _inc = inc + 1;
      continue ;
    }
    objects.push(Curry._1(convertBlockToObj([
                    /* Ground */7,
                    inc * 16,
                    Config.blockh(level) * 16
                  ])(idCounter), level));
    _inc = inc + 1;
    continue ;
  };
}

function generateHelper(idCounter, level) {
  var objects = [];
  generateBlocks(objects, 0, 0, idCounter, level);
  generateGround(objects, 0, idCounter, level);
  generateEnemiesOnGround(objects, 0, 0, idCounter, level);
  var panel = generatePanel(idCounter, level);
  objects.push(panel);
  return objects;
}

function newPlayer(playerNum) {
  var arg = playerNum ? ({
        TAG: /* Player2 */1,
        _0: /* SmallM */1
      }) : ({
        TAG: /* Player1 */0,
        _0: /* SmallM */1
      });
  var arg$1 = Sprite.playerParams(/* SmallM */1, /* Standing */0, /* Left */0, playerNum);
  return function (param) {
    var func = Curry._4($$Object.make, undefined, undefined, undefined, param);
    return function (param) {
      return Curry._5(func, param, arg, arg$1, 100, 224);
    };
  };
}

function generate(idCounter, level) {
  Random.init(Config.randomSeed(level));
  var initial = performance.now();
  var objects = generateHelper(idCounter, level);
  var elapsed = performance.now() - initial;
  console.log("generated", objects.length, "objects in " + (elapsed.toString() + " milliseconds"));
  return objects;
}

export {
  memPos ,
  trimEdge ,
  convertCoinToObj ,
  addCoins ,
  convertEnemyToObj ,
  randomEnemyTyp ,
  addEnemyOnBlock ,
  addBlock ,
  generateGroundStairs ,
  generateAirupStairs ,
  generateAirdownStairs ,
  generateClouds ,
  randomStairTyp ,
  chooseBlockPattern ,
  generateEnemiesOnGround ,
  generateBlocks ,
  generatePanel ,
  convertBlockToObj ,
  generateGround ,
  generateHelper ,
  newPlayer ,
  generate ,
  
}
/* Object Not a pure module */
